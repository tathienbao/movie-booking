package moviebooking.service;

import moviebooking.model.Movie;
import moviebooking.repository.MovieRepository;

import java.util.List;

/**
 * Service layer for Movie business logic.
 *
 * SERVICE LAYER RESPONSIBILITIES:
 * - Implements business logic and rules
 * - Coordinates between different repositories
 * - Handles transactions (if complex multi-step operations)
 * - Validates data before persistence
 * - Transforms data between API and database layers
 *
 * DESIGN PATTERN:
 * This follows the Layered Architecture pattern:
 * REST Resource → Service Layer → Repository → Database
 *
 * WHY NOT PUT LOGIC DIRECTLY IN REST RESOURCE?
 * - Separation of concerns (REST handles HTTP, Service handles business logic)
 * - Reusability (same service can be used by REST, CLI, scheduled jobs, etc.)
 * - Testability (easier to unit test without HTTP layer)
 *
 * MIGRATION FROM IN-MEMORY:
 * - Before: Used ConcurrentHashMap and AtomicLong
 * - After: Uses MovieRepository with JPA/Hibernate
 * - Benefits: Data persistence, ACID transactions, scalability
 */
public class MovieService {

    private final MovieRepository repository;

    /**
     * Constructor - receives repository via Dependency Injection pattern
     *
     * DEPENDENCY INJECTION:
     * Instead of creating MovieRepository inside this class (tight coupling),
     * we receive it from outside (loose coupling).
     *
     * Benefits:
     * - Easy to test (can inject mock repository)
     * - Flexible (can swap repository implementation)
     * - Clear dependencies (visible in constructor)
     */
    public MovieService(MovieRepository repository) {
        this.repository = repository;
    }

    /**
     * Get all movies.
     *
     * Simple delegation to repository.
     * If we needed business logic (e.g., filter only active movies,
     * apply user-specific permissions), we'd add it here.
     */
    public List<Movie> getAllMovies() {
        return repository.findAll();
    }

    /**
     * Get a movie by ID.
     *
     * Returns null if not found.
     * The REST layer will convert this to 404 Not Found.
     */
    public Movie getMovieById(Long id) {
        return repository.findById(id);
    }

    /**
     * Create a new movie.
     *
     * BUSINESS LOGIC we could add here:
     * - Validation: Check title is not empty, price > 0, etc.
     * - Normalization: Trim title, capitalize genre
     * - Deduplication: Check if movie with same title exists
     * - Notifications: Send email when new movie added
     *
     * For now, we keep it simple and delegate to repository.
     *
     * NOTE: ID is auto-generated by database (GenerationType.IDENTITY)
     * We don't need to set it manually anymore!
     */
    public Movie createMovie(Movie movie) {
        // Future business logic here
        // Example: if (movie.getPrice() <= 0) throw new IllegalArgumentException();

        return repository.save(movie);
    }

    /**
     * Update an existing movie.
     *
     * Returns null if movie doesn't exist.
     *
     * BUSINESS LOGIC we could add:
     * - Version checking (optimistic locking)
     * - Audit logging (who changed what, when)
     * - Validation rules
     */
    public Movie updateMovie(Movie movie) {
        // Check if movie exists
        if (repository.findById(movie.getId()) == null) {
            return null;  // Not found
        }

        // Update in database
        return repository.update(movie);
    }

    /**
     * Delete a movie by ID.
     *
     * Returns true if deleted, false if not found.
     *
     * BUSINESS LOGIC we could add:
     * - Check if movie has bookings (don't delete if booked)
     * - Soft delete (mark as deleted instead of actually deleting)
     * - Cascade delete (also delete related bookings)
     */
    public boolean deleteMovie(Long id) {
        return repository.delete(id);
    }
}
