package moviebooking.service;

import moviebooking.model.Movie;
import moviebooking.repository.MovieRepository;

import java.util.List;
import java.util.Objects;

/**
 * Service layer for Movie business logic.
 *
 * SERVICE LAYER RESPONSIBILITIES:
 * - Implements business logic and rules
 * - Coordinates between different repositories
 * - Handles transactions (if complex multi-step operations)
 * - Validates data before persistence
 * - Transforms data between API and database layers
 *
 * DESIGN PATTERN:
 * This follows the Layered Architecture pattern:
 * REST Resource → Service Layer → Repository → Database
 *
 * WHY NOT PUT LOGIC DIRECTLY IN REST RESOURCE?
 * - Separation of concerns (REST handles HTTP, Service handles business logic)
 * - Reusability (same service can be used by REST, CLI, scheduled jobs, etc.)
 * - Testability (easier to unit test without HTTP layer)
 *
 * MIGRATION FROM IN-MEMORY:
 * - Before: Used ConcurrentHashMap and AtomicLong
 * - After: Uses MovieRepository with JPA/Hibernate
 * - Benefits: Data persistence, ACID transactions, scalability
 */
public class MovieService {

    private final MovieRepository repository;

    /**
     * Constructor - receives repository via Dependency Injection pattern
     *
     * DEPENDENCY INJECTION:
     * Instead of creating MovieRepository inside this class (tight coupling),
     * we receive it from outside (loose coupling).
     *
     * Benefits:
     * - Easy to test (can inject mock repository)
     * - Flexible (can swap repository implementation)
     * - Clear dependencies (visible in constructor)
     *
     * CRITICAL FIX: Input validation
     * Added null check to prevent NPE if called with null repository.
     */
    public MovieService(MovieRepository repository) {
        this.repository = Objects.requireNonNull(repository,
            "MovieRepository cannot be null. Service requires valid repository instance.");
    }

    /**
     * Get all movies.
     *
     * Simple delegation to repository.
     * If we needed business logic (e.g., filter only active movies,
     * apply user-specific permissions), we'd add it here.
     */
    public List<Movie> getAllMovies() {
        return repository.findAll();
    }

    /**
     * Get a movie by ID.
     *
     * Returns null if not found.
     * The REST layer will convert this to 404 Not Found.
     */
    public Movie getMovieById(Long id) {
        return repository.findById(id);
    }

    /**
     * Create a new movie.
     *
     * BUSINESS LOGIC we could add here:
     * - Validation: Check title is not empty, price > 0, etc.
     * - Normalization: Trim title, capitalize genre
     * - Deduplication: Check if movie with same title exists
     * - Notifications: Send email when new movie added
     *
     * CRITICAL FIX: Input validation
     * Added comprehensive validation before persisting to database.
     *
     * NOTE: ID is auto-generated by database (GenerationType.IDENTITY)
     * We don't need to set it manually anymore!
     */
    public Movie createMovie(Movie movie) {
        // VALIDATION: Null check
        Objects.requireNonNull(movie, "Movie cannot be null");

        // VALIDATION: Required fields
        if (movie.getTitle() == null || movie.getTitle().trim().isEmpty()) {
            throw new IllegalArgumentException("Movie title cannot be empty");
        }

        if (movie.getGenre() == null || movie.getGenre().trim().isEmpty()) {
            throw new IllegalArgumentException("Movie genre cannot be empty");
        }

        // VALIDATION: Positive values
        if (movie.getPrice() == null || movie.getPrice() <= 0) {
            throw new IllegalArgumentException("Movie price must be positive (got: " + movie.getPrice() + ")");
        }

        if (movie.getDurationMinutes() == null || movie.getDurationMinutes() <= 0) {
            throw new IllegalArgumentException("Movie duration must be positive (got: " + movie.getDurationMinutes() + ")");
        }

        // NORMALIZATION: Trim whitespace
        movie.setTitle(movie.getTitle().trim());
        movie.setGenre(movie.getGenre().trim());
        if (movie.getDescription() != null) {
            movie.setDescription(movie.getDescription().trim());
        }

        return repository.save(movie);
    }

    /**
     * Update an existing movie.
     *
     * Returns null if movie doesn't exist.
     *
     * CRITICAL FIX: TOCTOU (Time-Of-Check to Time-Of-Use) race condition
     * Repository now checks existence WITHIN transaction (atomic operation).
     * The check and update happen in same transaction, preventing race condition.
     *
     * CRITICAL FIX: Input validation
     * Added same validation as createMovie() to prevent invalid updates.
     *
     * BUSINESS LOGIC we could add:
     * - Version checking (optimistic locking)
     * - Audit logging (who changed what, when)
     * - More complex validation rules
     */
    public Movie updateMovie(Movie movie) {
        // VALIDATION: Null check
        Objects.requireNonNull(movie, "Movie cannot be null");

        // VALIDATION: ID must be provided for update
        if (movie.getId() == null || movie.getId() <= 0) {
            throw new IllegalArgumentException("Movie ID must be positive for update (got: " + movie.getId() + ")");
        }

        // VALIDATION: Required fields (same as create)
        if (movie.getTitle() == null || movie.getTitle().trim().isEmpty()) {
            throw new IllegalArgumentException("Movie title cannot be empty");
        }

        if (movie.getGenre() == null || movie.getGenre().trim().isEmpty()) {
            throw new IllegalArgumentException("Movie genre cannot be empty");
        }

        // VALIDATION: Positive values
        if (movie.getPrice() == null || movie.getPrice() <= 0) {
            throw new IllegalArgumentException("Movie price must be positive (got: " + movie.getPrice() + ")");
        }

        if (movie.getDurationMinutes() == null || movie.getDurationMinutes() <= 0) {
            throw new IllegalArgumentException("Movie duration must be positive (got: " + movie.getDurationMinutes() + ")");
        }

        // NORMALIZATION: Trim whitespace
        movie.setTitle(movie.getTitle().trim());
        movie.setGenre(movie.getGenre().trim());
        if (movie.getDescription() != null) {
            movie.setDescription(movie.getDescription().trim());
        }

        // Update in database (atomic operation)
        // merge() will throw if constraints are violated
        return repository.update(movie);
    }

    /**
     * Delete a movie by ID.
     *
     * Returns true if deleted, false if not found.
     *
     * BUSINESS LOGIC we could add:
     * - Check if movie has bookings (don't delete if booked)
     * - Soft delete (mark as deleted instead of actually deleting)
     * - Cascade delete (also delete related bookings)
     */
    public boolean deleteMovie(Long id) {
        return repository.delete(id);
    }
}
